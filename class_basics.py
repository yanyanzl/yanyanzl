
'''
Prior to delving into metaclasses, a solid grasp of Python classes is beneficial. 
Python holds a particularly distinctive concept of classes, 
a notion it adopts from the Smalltalk language.

In most languages, classes are just pieces of code that describe how to produce an object. 
That is somewhat true in Python too:

'''
class ObjectCreator(object):
    pass

my_object = ObjectCreator()

print(my_object)


'''
But classes are more than that in Python. Classes are objects too.

Yes, objects.

When a Python script runs, every line of code is executed from top to bottom. 
When the Python interpreter encounters the class keyword, 
Python creates an object out of the "description" of the class that follows. 
Thus, the following instruction

...creates an object with the name ObjectCreator!

This object (the class) is itself capable of creating objects (called instances).

But still, it's an object. Therefore, like all objects:

'''

# you can assign it to a variable1
JustAnotherVariable = ObjectCreator

# you can attach attributes to it
ObjectCreator.class_attribute = 'foo'
print(ObjectCreator.class_attribute)

# you can pass it as a function parameter
print(ObjectCreator)

print(JustAnotherVariable)

# instance of the class. 
print(JustAnotherVariable())

''' 
Creating classes dynamically
Since classes are objects, you can create them on the fly, like any object.
First, you can create a class in a function using class:
'''

def choose_class(name):
    if name == 'foo':
        class Foo(object):
            pass
        return Foo # return the class, not an instance
    else:
        class Bar(object):
            pass
        return Bar

MyClass = choose_class('foo')

print(MyClass) # the function returns a class, not an instance


print(MyClass()) # you can create an object from this class

''' 
But it's not so dynamic, since you still have to write the whole class yourself.
Since classes are objects, they must be generated by something.
When you use the class keyword, Python creates this object automatically.

But as with most things in Python, it gives you a way to do it manually.
Remember the function type? The good old function that lets you know what type an object is:
'''

print(type(1))

print(type(ObjectCreator))

print(type(ObjectCreator()))


'''
Well, type has also a completely different ability: it can create classes on the fly. 
type can take the description of a class as parameters, and return a class.
type works this way:
    type(name, bases, attrs)
        Where:
            name: name of the class
            bases: tuple of the parent class (for inheritance, can be empty)
            attrs: dictionary containing attributes names and values

e.g.:
class MyShinyClass(object):
    pass
    
can be created manually this way:
'''

MyShinyClass = type('MyShinyClass', (), {}) # returns a class object
print(MyShinyClass)
print(MyShinyClass()) # create an instance with the class


'''
type accepts a dictionary to define the attributes of the class. So:
class Foo(object):
    bar = True
Can be translated to:
'''
Foo = type('Foo', (), {'bar':True})
print(Foo)
print(Foo.bar)

f = Foo()
print(f)
f.bar = False
print(f.bar)

print(Foo.bar)


'''
And of course, you can inherit from it, so:

class FooChild(Foo):
     pass

would be:

FooChild = type('FooChild', (Foo,), {})
print(FooChild)
print(FooChild.bar) # bar is inherited from Foo

Eventually, you'll want to add methods to your class. 
Just define a function with the proper signature and assign it as an attribute.

'''


def echo_bar(self):
    print(self.bar)

FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})

print(f"hasattr(Foo, 'echo_bar') is {hasattr(Foo, 'echo_bar')}")
print(f"hasattr(FooChild, 'echo_bar') is {hasattr(FooChild, 'echo_bar')}")

hasattr(FooChild, 'echo_bar')

my_foo = FooChild()
my_foo.echo_bar()

'''
And you can add even more methods after you dynamically create the class, 
just like adding methods to a normally created class object.

'''

def echo_bar_more(self):
    print('yet another method')

FooChild.echo_bar_more = echo_bar_more
print(f"hasattr(FooChild, 'echo_bar_more') is {hasattr(FooChild, 'echo_bar_more')}")

FooChild.football = "england"
print(f"hasattr(FooChild, 'football') is {hasattr(FooChild, 'football')}")
foo_child = FooChild()
print(f"foo_child.football is {foo_child.football}")


'''
You see where we are going: in Python, classes are objects, and you can create a class on the fly, 
dynamically.

This is what Python does when you use the keyword class, and it does so by using a metaclass.

What are metaclasses? 

    Metaclasses are the 'stuff' that creates classes.
    You define classes in order to create objects, right?
    But we learned that Python classes are objects.
    Well, metaclasses are what create these objects. They are the classes' classes, 
    you can picture them this way:
        MyClass = MetaClass()
        my_object = MyClass()

    You've seen that type lets you do something like this:
        MyClass = type('MyClass', (), {})
    It's because the function type is in fact a metaclass. 
    type is the metaclass Python uses to create all classes behind the scenes.

    Now you wonder "why the heck is it written in lowercase, and not Type?"
    Well, I guess it's a matter of consistency with str, the class that creates strings objects, 
    and int the class that creates integer objects. type is just the class that creates class objects.

    You see that by checking the __class__ attribute.
    Everything, and I mean everything, is an object in Python. 
    That includes integers, strings, functions and classes. 
    All of them are objects. And all of them have been created from a class:

        
'''

age = 35
name = 'steven'
def foo(): pass
class Bar(object):pass

print(f"age.__class__ is {age.__class__}")
print(f"name.__class__ is {name.__class__}")
print(f"foo.__class__ is {foo.__class__}")
print(f"Bar.__class__ is {Bar.__class__}")


# Now, what is the __class__ of any __class__ ?

print(f"age.__class__ is {age.__class__.__class__}")
print(f"name.__class__ is {name.__class__.__class__}")
print(f"foo.__class__ is {foo.__class__.__class__}")
print(f"Bar.__class__ is {Bar.__class__.__class__}")

'''
So, a metaclass is just the stuff that creates class objects.
You can call it a 'class factory' if you wish.
type is the built-in metaclass Python uses, but of course, you can create your own metaclass.

The syntax to set the metaclass has been changed in Python 3:
class Foo(object, metaclass=something):
    ...


Custom metaclasses
    The main purpose of a metaclass is to change the class automatically, when it's created.
    You usually do this for APIs, where you want to create classes matching the current context.

Imagine a stupid example, where you decide that all classes in your module should 
have their attributes written in uppercase. There are several ways to do this, 
but one way is to set __metaclass__ at the module level.

This way, all classes of this module will be created using this metaclass, 
and we just have to tell the metaclass to turn all attributes to uppercase.

'''

class UpperAttrMetaclass(type):
    def __new__(cls, clsname, bases, attrs):
        uppercase_attrs = {
            attr if attr.startswith("__") else attr.upper(): v
            for attr, v in attrs.items()
        }

        # Python 2 requires passing arguments to super:
        # return super(UpperAttrMetaclass, cls).__new__(
        #     cls, clsname, bases, uppercase_attrs)

        # Python 3 can use no-arg super() which infers them:
        return super().__new__(cls, clsname, bases, uppercase_attrs)
    
class Football(object, metaclass=UpperAttrMetaclass):
    bar = "this is uppercase metaclass"

print(f"hasattr(Football,'bar') is {hasattr(Football,'bar')}")
print(f"hasattr(Football,'BAR') is {hasattr(Football,'BAR')}")
print(f"Football.BAR is {Football.BAR}")
print(f"id(Foo) is {id(Foo)}")

'''
That's it. There is really nothing more about metaclasses.

The reason behind the complexity of the code using metaclasses is not because of metaclasses, 
it's because you usually use metaclasses to do twisted stuff relying on introspection, 
manipulating inheritance, vars such as __dict__, etc.

Indeed, metaclasses are especially useful to do black magic, and therefore complicated stuff. 
But by themselves, they are simple:
    intercept a class creation
    modify the class
    return the modified class

Metaclasses are deeper magic that 99% of users should never worry about it. 
If you wonder whether you need them, you don't 
(the people who actually need them know with certainty that they need them, 
and don't need an explanation about why).


The main use case for a metaclass is creating an API. 
A typical example of this is the Django ORM. It allows you to define something like this:

    class Person(models.Model):
        name = models.CharField(max_length=30)
        age = models.IntegerField()

    if you do this:
    
    person = Person(name='bob', age='35')
    print(person.age)


It won't return an IntegerField object. It will return an int, 
and can even take it directly from the database.

This is possible because models.Model defines __metaclass__ and 
it uses some magic that will turn the Person you just defined 
with simple statements into a complex hook to a database field.

Django makes something complex look simple by exposing 
a simple API and using metaclasses, 
recreating code from this API to do the real job behind the scenes.

Everything is an object in Python, and they are all either instance of classes or instances of metaclasses.

Except for type.
Secondly, metaclasses are complicated. You may not want to use them for very simple class alterations. You can change classes by using two different techniques:

    monkey patching
    class decorators
99% of the time you need class alteration, you are better off using these.

But 98% of the time, you don't need class alteration at all.
'''

